<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="UP"><meta name="renderer" content="webkit"><meta name="copyright" content="UP"><meta name="keywords" content="Hexo"><meta name="description" content="欢迎来到垃圾站"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>传输协议 · UP的博客</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/saveabc.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">UP</div><div class="profile-signature">只要你多做一天牛马,你就又做了一天牛马</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(img/assets/bg.jpg);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">UP的博客</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/archives/">Archives</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/archives/">Archives</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">传输协议</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-edit"></i><span>2024-12-07 16:11:50</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="操作"> 操作</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">2k</span> | Reading time: <span class="post-count">7</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h1><h2 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h2><p><code>ACK</code>确认请求</p>
<p><code>SYN</code>连接请求</p>
<p><code>FIN</code>释放请求&#96;</p>
<h3 id="三次握手建立连接："><a href="#三次握手建立连接：" class="headerlink" title="三次握手建立连接："></a>三次握手建立连接：</h3><p>A -&gt; B	SYN</p>
<p>B -&gt; A 	ACK + SYN</p>
<p>A -&gt; B 	SYN</p>
<h3 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h3><p>一般网络不能发送任意长度的数据,需分割为小块, 称为数据包并按照顺序分别发送</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>确保数据正确未被篡改</p>
<h3 id="防乱序"><a href="#防乱序" class="headerlink" title="防乱序"></a>防乱序</h3><p>由于接收到的数据包可能是乱序的, 所以重组数据包时需要按照一定协议进行组装</p>
<ul>
<li>TCP在数据包头部定义了一个序列号用于排序</li>
</ul>
<h3 id="防丢包"><a href="#防丢包" class="headerlink" title="防丢包"></a>防丢包</h3><p>为保证所有数据包都被正确接收, 采用ACK包应答确认，采用重传计时器进行接收判断</p>
<p>TCP通过丢包感知网络拥堵情况</p>
<ul>
<li><p>超时重传：由超时机制判断的重传</p>
</li>
<li><p>快速重传：连续接收三个相同确认号就判定为丢包</p>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>A -&gt; B  FIN </p>
<p>B -&gt; A	ACK</p>
<p>B -&gt; A	FIN</p>
<p>A -&gt; B	ACK</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>1个窗口为停等协议，多个窗口为；流水线协议，为防止丢包，接收方通常根据发送方窗口动态调整窗口大小</p>
<ul>
<li><p>停等协议：发送方发送数据之后需等到接收方确认以后才能继续发送(发送-等待-确认-再发送)	发送方处于等待阶段，数据包的往返时间越长会导致吞吐量降低，吞吐量变差</p>
</li>
<li><p>流水线协议：允许发送方发送数据包而无需等待确认，在TCP数据包报文头传输过程中携带窗口大小，但是如果连续发送过多数据包会导致接收方无法全部接收，造成丢包影响传输效率</p>
</li>
</ul>
<p><img src="https://savebiu.github.io/Image/image-20241206171422620.png" alt="image-20241206171422620"></p>
<p><img src="https://savebiu.github.io/Image/image-20241206171626883.png" alt="image-20241206171626883"></p>
<h4 id="拥塞窗口cwnd"><a href="#拥塞窗口cwnd" class="headerlink" title="拥塞窗口cwnd"></a>拥塞窗口cwnd</h4><p>注入过多会造成网络堵塞，减少拥塞窗口cwnd</p>
<p>网络畅通则增加接收窗口rwnd</p>
<p>发送窗口 &#x3D; min(cwnd, rwnd)</p>
<h4 id="Reno算法"><a href="#Reno算法" class="headerlink" title="Reno算法"></a>Reno算法</h4><p>常用于拥塞的算法<code>Reno</code>包含四个步骤：{慢启动，拥塞避免， 快速重传， 快速回复}</p>
<ul>
<li><p>慢启动：由小到大增加拥塞窗口数量，每次增加一倍拥塞窗口数量（呈指数增长），当网络拥堵时慢启动结束</p>
<p>  <img src="https://savebiu.github.io/Image/image-20241206202141236.png" alt="image-20241206202141236"></p>
</li>
<li><p>拥塞避免</p>
</li>
<li><p>快速重传</p>
</li>
<li><p>快速回复</p>
</li>
</ul>
<hr>
<h4 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h4><ul>
<li><strong>可靠性</strong>：TCP 是面向连接的协议，确保数据从发送端到接收端的可靠传输。</li>
<li><strong>顺序性</strong>：TCP 保证数据包 **按照发送顺序 **到达接收端。</li>
<li><strong>流量控制</strong>：通过滑动窗口机制来控制数据传输速率，避免网络拥塞。</li>
<li><strong>拥塞控制</strong>：当网络出现拥堵时，TCP 会通过算法（如慢启动、拥塞避免等）调整数据传输速率。</li>
<li><strong>错误校验与重传</strong>：TCP 提供了错误检测和 <strong>丢包重传</strong> 机制，确保数据传输的完整性。</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>连接导向</strong>：需要建立连接（ <strong>三次握手</strong> ）来开始通信。</li>
<li><strong>可靠性</strong>：数据保证 <strong>可靠</strong> 传输， <strong>不会丢失</strong> 、<strong>不乱序</strong> 。</li>
<li><strong>适用场景</strong>：适用于需要高可靠性和有序性的应用，如文件传输、网页浏览、电子邮件等。</li>
</ul>
<h2 id="UDP（用户数据报协议）"><a href="#UDP（用户数据报协议）" class="headerlink" title="UDP（用户数据报协议）"></a>UDP（用户数据报协议）</h2><h4 id="框架：-1"><a href="#框架：-1" class="headerlink" title="框架："></a>框架：</h4><ul>
<li><strong>无连接</strong>：UDP 是 <strong>无连接</strong> 的协议，不需要建立连接，数据直接从发送端传输到接收端。</li>
<li><strong>不保证可靠性</strong>：UDP  <strong>不提供数据重传</strong> 、流量控制、拥塞控制等机制，数据可能丢失或乱序。</li>
<li><strong>高效性</strong>：由于不需要连接和确认机制，UDP 相对 TCP 更加高效，适合 <strong>低延迟</strong> 应用。</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>无连接</strong>：无需建立连接，可以直接发送数据。</li>
<li><strong>不保证可靠性</strong>：可能丢失、重复或乱序的包。</li>
<li><strong>适用场景</strong>：适用于实时性要求高，但对 <strong>数据丢失不敏感</strong> 的应用，如视频流、实时游戏、语音通话等。</li>
</ul>
<p>UDP协议有更高的灵活性，每个UDP消息可以是独立的，不依赖于连接，消息不需要通过握手建立连接。</p>
<h2 id="KCP（KCP协议）"><a href="#KCP（KCP协议）" class="headerlink" title="KCP（KCP协议）"></a>KCP（KCP协议）</h2><h4 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h4><p>KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据的发送方式，以 callback的方式提供给 KCP。连时钟都需要外部传递进来，内部不会有任何一次系统调用。<br>TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。</p>
<h4 id="框架：-2"><a href="#框架：-2" class="headerlink" title="框架："></a>框架：</h4><ul>
<li><strong>改进的 UDP</strong>：KCP 协议基于 UDP 构建<strong>（无连接）</strong>，提供类似于 TCP 的可靠传输功能，但在性能上做了优化。</li>
<li><strong>可靠传输</strong>：通过实现自己的确认、重传、流量控制等机制，KCP 可以提供可靠的传输。</li>
<li><strong>低延迟</strong>：相比 TCP，KCP 具有更 <strong>低的延迟</strong> ，因为它不依赖于操作系统内核的 TCP 协议栈，直接进行数据包的管理和传输。</li>
<li><strong>拥塞控制</strong>：KCP 实现了自定义的 <strong>拥塞控制</strong> 机制，以减少网络拥塞对数据传输的影响。</li>
<li><strong>自定义参数</strong>：KCP 允许用户定制参数，如重传次数、发送间隔、窗口大小等，以满足不同场景的需求。</li>
</ul>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>基于 UDP</strong>：KCP 本质上是对 UDP 进行了增强，提供 <strong>可靠传输</strong> 的同时，保持 <strong>低延迟</strong> 。</li>
<li><strong>高效的传输控制</strong>：具有 TCP 的可靠性和 UDP 的低延迟特性，适合高吞吐量和低延迟的场景。</li>
<li><strong>适用场景</strong>：适用于要求低延迟和高吞吐量的应用，如在线游戏、视频直播等。</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><p>传输层的数据叫作段(segment)，网络层的数据叫作包(packet)，数据链路层的数据叫作帧(frame)，物理层的数据叫作流(stream)</p>
</li>
<li><p>在网络中，我们认为传输是不可靠的，而在很多场景下我们需要的是可靠的数据，所谓的可靠，指的是数据能够正常收到，且能够顺序收到，于是就有了ARQ协议，TCP之所以可靠就是基于此。</p>
</li>
<li><p><strong>ARQ协议</strong> (Automatic Repeat-reQuest)，即自动重传请求，是传输层的错误纠正协议之一，它通过使用累计确认和超时两个机制，在不可靠的网络上实现可靠的信息传输。</p>
</li>
<li><p><strong>RTO</strong> (Retransmission-TimeOut)即重传超时时间，TCP是基于ARQ协议实现的可靠性，KCP也是基于ARQ协议实现的可靠性，但TCP的超时计算是RTO<em>2，而KCP的超时计算是RTO</em>1.5，也就是说假如连续丢同一个包3次，TCP第3次重传是RTO<em>8，而KCP则是RTO</em>3.375，意味着可以更快地重新传输数据。通过4字节ts计算RTT(Round-Trip-Time)即往返时延，再通过RTT计算RTO，ts(timestamp)即当前segment发送时的时间戳。</p>
</li>
<li><p><strong>快速重传</strong> 与TCP相同，都是通过累计确认实现的，发送端发送了1，2，3，4，5几个包，然后收到远端的ACK：1，3，4，5，当收到ACK &#x3D; 3时，KCP知道2被跳过1次，收到ACK &#x3D; 4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号，大大改善了丢包时的传输速度。1字节cmd &#x3D; 81时，sn相当于TCP中的seq，cmd &#x3D; 82时，sn表示收到的但不连续的序号。cmd相当于WebSocket协议中的openCode，即操作码。</p>
</li>
<li><p>通常使用UDP来实现KCP的原因是由于UDP的头部相对于TCP的头部来说更小，且KCP相对于TCP来说有太多的冗余功能，这样白白导致了很多不必要的开销</p>
</li>
</ul>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">UP</a></p><p> <span>Link:  </span><a href="http://example.com/2024/12/07/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/">http://example.com/2024/12/07/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2024/12/07/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="背包系统"><span>< PreviousPost</span><br><span class="prevTitle">背包系统</span></a><a class="nextSlogan" href="/2024/12/06/%E4%BC%9A%E8%AE%AE12_1/" title="会议12_1"><span>NextPost ></span><br><span class="nextTitle">会议12_1</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">传输协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">TCP（传输控制协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">三次握手建立连接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.1.3.</span> <span class="toc-text">校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">防乱序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E4%B8%A2%E5%8C%85"><span class="toc-number">1.1.5.</span> <span class="toc-text">防丢包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">拥塞窗口cwnd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reno%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">Reno算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%EF%BC%9A"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">框架：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%EF%BC%88%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">UDP（用户数据报协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%EF%BC%9A-1"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">框架：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KCP%EF%BC%88KCP%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">KCP（KCP协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">官网介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%EF%BC%9A-2"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">框架：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>